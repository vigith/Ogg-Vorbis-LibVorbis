.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Ogg::Vorbis::LibVorbis 3"
.TH Ogg::Vorbis::LibVorbis 3 "2012-03-19" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Ogg::Vorbis::LibVorbis \- XS Interface for calling Vorbis Audio Codec functions in Perl.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Ogg::Theora::LibVorbis is a glue between vorbis/codec.h, vorbis/vorbisenc.h and vorbis/vorbisfile.h
Please read the \s-1XS\s0 code to understand how the gluing happens.
.SH "SYNOPSIS ENCODE"
.IX Header "SYNOPSIS ENCODE"
Encoding .wav format to Vorbis Audio format <http://svn.xiph.org/trunk/vorbis/examples/encoder_example.c>
.PP
.Vb 15
\&  ##############################################################################################################################################################
\&  # (1) Initialize a vorbis_info structure by calling vorbis_info_init and then functions from libvorbisenc on it.                                             #
\&  # (2) Initialize a vorbis_dsp_state for encoding based on the parameters in the vorbis_info by using vorbis_analysis_init.                                   #
\&  # (3) Initialize a vorbis_comment structure using vorbis_comment_init, populate it with any comments you wish to store                                       #
\&  #     in the stream, and call vorbis_analysis_headerout to get the three Vorbis stream header packets. Output the packets.                                   #
\&  # (4) Initialize a vorbis_block structure using vorbis_block_init.                                                                                           #
\&  # (5) While there is more audio to encode:                                                                                                                   #
\&  #       (5.a) Submit a chunk of audio data using vorbis_analysis_buffer and vorbis_analysis_wrote.                                                           #
\&  #       (5.b) Obtain all available blocks using vorbis_analysis_blockout in a loop. For each block obtained:                                                 #
\&  #           (5.b.1) Encode the block into a packet (or prepare it for bitrate management) using vorbis_analysis.                                             #
\&  #           (5.b.2) If you are using bitrate management, submit the block using vorbis_bitrate_addblock and obtain packets using vorbis_bitrate_flushpacket. #
\&  #           (5.b.3) Output any obtained packets.                                                                                                             #
\&  # (6) Submit an empty buffer to indicate the end of input; this will result in an end-of-stream packet after all encoding steps are done to it.              #
\&  # (7) Destroy the structures using the appropriate vorbis_*_clear routines.                                                                                  #
\&  ##############################################################################################################################################################
.Ve
.PP
.Vb 3
\&  use Ogg::LibOgg ':all';
\&  use Ogg::Vorbis::LibVorbis;
\&  use Audio::Wav;
.Ve
.PP
.Vb 7
\&  ## Wav Audio File Info
\&  my $wav = new Audio::Wav; 
\&  my $read = $wav->read("t/test.wav"); 
\&  my $details = $read->details();
\&  my $channels = $details->{channels}; # 2
\&  my $rate = $details->{sample_rate};  # 22050
\&  my $length = $read->length_samples(); # 48066
.Ve
.PP
.Vb 7
\&  ## Ogg Pages
\&  my $op_h      = make_ogg_packet();
\&  my $op_hcomm = make_ogg_packet();
\&  my $op_hcode = make_ogg_packet();
\&  my $op_audio   = make_ogg_packet();
\&  my $os   = make_ogg_stream_state();
\&  my $og = make_ogg_page();
.Ve
.PP
.Vb 11
\&  my $vi = Ogg::Vorbis::LibVorbis::make_vorbis_info(); # vorbis_info
\&  my $vc = Ogg::Vorbis::LibVorbis::make_vorbis_comment(); # vorbis_comment
\&  my $vb = Ogg::Vorbis::LibVorbis::make_vorbis_block(); # vorbis_block
\&  Ogg::Vorbis::LibVorbis::vorbis_info_init($vi);
\&  my $v = Ogg::Vorbis::LibVorbis::make_vorbis_dsp_state(); # vorbis_dsp_state
\&  my $ret = Ogg::Vorbis::LibVorbis::vorbis_encode_init_vbr($vi, $channels, $rate, 1.0);
\&  $ret = Ogg::Vorbis::LibVorbis::vorbis_analysis_init($v, $vi);
\&  $ret = Ogg::Vorbis::LibVorbis::vorbis_encode_setup_init($vi);
\&  Ogg::Vorbis::LibVorbis::vorbis_comment_init($vc);
\&  $ret = Ogg::Vorbis::LibVorbis::vorbis_block_init($v, $vb);
\&  $ret = Ogg::Vorbis::LibVorbis::vorbis_analysis_headerout($v, $vc, $op_h, $op_hcomm, $op_hcode);
.Ve
.PP
.Vb 4
\&  $ret = ogg_stream_init($os, int(rand(1000)));
\&  $ret = ogg_stream_packetin($os, $op_h);
\&  $ret = ogg_stream_packetin($os, $op_hcomm);
\&  $ret = ogg_stream_packetin($os, $op_hcode);
.Ve
.PP
.Vb 3
\&  my $filename = "t/vorbis_encode.ogg";
\&  open OUT, ">", "$filename" or die "can't open $filename for writing [$!]";
\&  binmode OUT;
.Ve
.PP
.Vb 2
\&  save_page();
\&  1 while (add_frames());
.Ve
.PP
.Vb 1
\&  close OUT;
.Ve
.PP
.Vb 11
\&  sub save_page {
\&    ## forms packets to pages 
\&    if (ogg_stream_pageout($os, $og) != 0) {
\&      my $h_page = get_ogg_page($og);
\&      ## writes the header and body 
\&      print OUT $h_page->{header};
\&      print OUT $h_page->{body};
\&    } else {
\&      # pass, we don't have to worry about insufficient data
\&    }
\&  }
.Ve
.PP
.Vb 3
\&  sub add_frames {
\&    my $data = $read->read_raw_samples($channels);
\&    my $no = $read->position_samples();
.Ve
.PP
.Vb 2
\&    # vorbis_encode_wav_frames(v, vals, channels, buffer)
\&    my $status = Ogg::Vorbis::LibVorbis::vorbis_encode_wav_frames($v, 1024, $channels, $data);
.Ve
.PP
.Vb 11
\&    # while (vorbis_analysis_blockout(self.vd, self.vb) == 1)
\&    #   vorbis_analysis(self.vb,self.audio_pkt)
\&    #   ogg_stream_packetin(self.to,self.audio_pkt)
\&    while (($status = Ogg::Vorbis::LibVorbis::vorbis_analysis_blockout($v, $vb)) == 1) {
\&      $status = Ogg::Vorbis::LibVorbis::vorbis_analysis($vb, $op_audio);
\&      if ($status < 0) {
\&        diag ("Crap Out, some error [$status]");
\&        exit -1;
\&      }
\&      ogg_stream_packetin($os, $op_audio);
\&    }
.Ve
.PP
.Vb 1
\&    save_page();
.Ve
.PP
.Vb 2
\&    return $length == $no ? 0 : 1
\&  }
.Ve
.SH "SYNOPSIS DECODE (vorbisfile)"
.IX Header "SYNOPSIS DECODE (vorbisfile)"
Decoding Vorbis file using vorbisfile <http://xiph.org/vorbis/doc/vorbisfile/example.html>
.PP
.Vb 2
\&  use Ogg::Vorbis::LibVorbis;
\&  use Ogg::LibOgg ':all';
.Ve
.PP
.Vb 2
\&  my $vf = Ogg::Vorbis::LibVorbis::make_oggvorbis_file();  # OggVorbis_File
\&  my $vi = Ogg::Vorbis::LibVorbis::make_vorbis_info();     # vorbis_info
.Ve
.PP
.Vb 2
\&  my $filename = "t/test.ogg";
\&  open IN, $filename or die "can't open [$filename] : $!";
.Ve
.PP
.Vb 12
\&  $status = Ogg::Vorbis::LibVorbis::ov_open_callbacks(*IN, $vf, 0, 0);  # $status == 0
\&  my $pcmout = 0;               # i know setting to -1 is of no use, but to avoid warning (_xs_ says NO_INIT)
\&  my $bit = 0;
\&  my $ret = -1;
\&  open OUT, "> output.pcm" or die "can't open output.pcm\en";
\&  binmode OUT;
\&  my $total = 0;
\&  while ($ret != 0) {
\&    $ret = Ogg::Vorbis::LibVorbis::ov_read($vf, $pcmout, 4096, 0, 2, 1, $bit);
\&    print OUT $pcmout;
\&  }
\&  close OUT;
.Ve
.PP
.Vb 1
\&  Ogg::Vorbis::LibVorbis::ov_clear($vf);
.Ve
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
Only constants are exported by \s-1DEFAULT\s0
.PP
.Vb 1
\&  use Ogg::Theora::LibVorbis ':all'; # to export everything to current namespace
.Ve
.Sh "Exportable constants"
.IX Subsection "Exportable constants"
.Vb 29
\&  INITSET
\&  NOTOPEN
\&  OPENED
\&  OV_EBADHEADER
\&  OV_EBADLINK
\&  OV_EBADPACKET
\&  OV_ECTL_IBLOCK_GET
\&  OV_ECTL_IBLOCK_SET
\&  OV_ECTL_LOWPASS_GET
\&  OV_ECTL_LOWPASS_SET
\&  OV_ECTL_RATEMANAGE2_GET
\&  OV_ECTL_RATEMANAGE2_SET
\&  OV_ECTL_RATEMANAGE_AVG
\&  OV_ECTL_RATEMANAGE_GET
\&  OV_ECTL_RATEMANAGE_HARD
\&  OV_ECTL_RATEMANAGE_SET
\&  OV_EFAULT
\&  OV_EIMPL
\&  OV_EINVAL
\&  OV_ENOSEEK
\&  OV_ENOTAUDIO
\&  OV_ENOTVORBIS
\&  OV_EOF
\&  OV_EREAD
\&  OV_EVERSION
\&  OV_FALSE
\&  OV_HOLE
\&  PARTOPEN
\&  STREAMSET
.Ve
.SH "Functions (malloc)"
.IX Header "Functions (malloc)"
<http://www.xiph.org/vorbis/doc/vorbisfile/datastructures.html>
.Sh "make_oggvorbis_file"
.IX Subsection "make_oggvorbis_file"
Creates a memory allocation for OggVorbis_File datastructure
.PP
\&\-Input:
  Void
.PP
\&\-Output:
  Memory Pointer
.SH "make_vorbis_info"
.IX Header "make_vorbis_info"
Creates a memory allocation for vorbis_info
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer to vorbis_info
.SH "make_vorbis_comment"
.IX Header "make_vorbis_comment"
Creates a memory allocation for vorbis_comment
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer to vorbis_comment
.SH "make_vorbis_block"
.IX Header "make_vorbis_block"
Creates a memory allocation for vorbis_block
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer to vorbis_block
.SH "make_vorbis_dsp_state"
.IX Header "make_vorbis_dsp_state"
Creates a memory allocation for vorbis_dsp_state
.PP
\&\-Input:
  void
.PP
\&\-Output:
  Memory Pointer to vorbis_dsp_state
.SH "Functions (vorbisfile)"
.IX Header "Functions (vorbisfile)"
<http://www.xiph.org/vorbis/doc/vorbisfile/reference.html>
.Sh "ov_open"
.IX Subsection "ov_open"
ov_open is one of three initialization functions used to initialize an OggVorbis_File 
structure and prepare a bitstream for playback. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_open.html>
.PP
\&\-Input:
  \s-1FILE\s0 *, File pointer to an already opened file or pipe,
  OggVorbis_File, A pointer to the OggVorbis_File structure,
  char *, Typically set to \s-1NULL\s0,
  int, Typically set to 0.
.PP
\&\-Output:
  0 indicates succes,
  less than zero for failure:
.PP
.Vb 5
\&    OV_EREAD - A read from media returned an error.
\&    OV_ENOTVORBIS - Bitstream is not Vorbis data.
\&    OV_EVERSION - Vorbis version mismatch.
\&    OV_EBADHEADER - Invalid Vorbis bitstream header.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
.Ve
.Sh "ov_fopen"
.IX Subsection "ov_fopen"
This is the simplest function used to open and initialize an OggVorbis_File structure.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_fopen.html>
.PP
\&\-Input:
  char *, (null terminated string containing a file path suitable for passing to \fIfopen()\fR)
  OggVorbis_File
.PP
\&\-Output:
  0 indicates success
  less than zero for failure:
.PP
.Vb 5
\&    OV_EREAD - A read from media returned an error.
\&    OV_ENOTVORBIS - Bitstream does not contain any Vorbis data.
\&    OV_EVERSION - Vorbis version mismatch.
\&    OV_EBADHEADER - Invalid Vorbis bitstream header.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
.Ve
.Sh "ov_open_callbacks"
.IX Subsection "ov_open_callbacks"
an alternative function used to open and initialize an OggVorbis_File structure when using a data source 
other than a file, when its necessary to modify default file access behavior.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_open.html>
.PP
\&\fBPlease read the official ov_open_callbacks doc before you use this.\fR The perl version uses
a different approach and uses vorbis_callbacks with custom functions to read, seek tell and close.
.PP
\&\fBthis module can accept file name, network socket or a file pointer.\fR
.PP
\&\-Input:
  void *, (data source)
  OggVorbis_File, A pointer to the OggVorbis_File structure,
  char *, Typically set to \s-1NULL\s0,
  int, Typically set to 0.
.PP
\&\-Output:
  0 indicates succes,
  less than zero for failure:
.PP
.Vb 5
\&    OV_EREAD - A read from media returned an error.
\&    OV_ENOTVORBIS - Bitstream is not Vorbis data.
\&    OV_EVERSION - Vorbis version mismatch.
\&    OV_EBADHEADER - Invalid Vorbis bitstream header.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
.Ve
.Sh "ov_test"
.IX Subsection "ov_test"
This partially opens a vorbis file to test for Vorbis\-ness.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_test.html>
.PP
\&\-Input:
  \s-1FILE\s0 *, File pointer to an already opened file or pipe,
  OggVorbis_File, A pointer to the OggVorbis_File structure,
  char *, Typically set to \s-1NULL\s0,
  int, Typically set to 0.
.PP
\&\-Output:
  0 indicates succes,
  less than zero for failure:
.PP
.Vb 5
\&    OV_EREAD - A read from media returned an error.
\&    OV_ENOTVORBIS - Bitstream is not Vorbis data.
\&    OV_EVERSION - Vorbis version mismatch.
\&    OV_EBADHEADER - Invalid Vorbis bitstream header.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
.Ve
.Sh "ov_test_open"
.IX Subsection "ov_test_open"
Finish opening a file partially opened with \fIov_test()\fR or \fIov_test_callbacks()\fR. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_test_open.html>
.PP
\&\-Input:
  OggVorbis_File
.PP
\&\-Output:
  0 indicates succes,
  less than zero for failure:
.PP
.Vb 5
\&    OV_EREAD - A read from media returned an error.
\&    OV_ENOTVORBIS - Bitstream is not Vorbis data.
\&    OV_EVERSION - Vorbis version mismatch.
\&    OV_EBADHEADER - Invalid Vorbis bitstream header.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
.Ve
.Sh "ov_test_callbacks"
.IX Subsection "ov_test_callbacks"
an alternative function used to open and test an OggVorbis_File structure when using a data source
other than a file, when its necessary to modify default file access behavior.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_test_callbacks.html>
.PP
\&\fBPlease read the official ov_test_callbacks doc before you use this.\fR The perl version uses
a different approach and uses vorbis_callbacks with custom functions to read, seek tell and close.
.PP
\&\fBthis module can accept file name, network socket or a file pointer.\fR
.PP
\&\-Input:
  void *, (data source)
  OggVorbis_File, A pointer to the OggVorbis_File structure,
  char *, Typically set to \s-1NULL\s0,
  int, Typically set to 0.
.PP
\&\-Output:
  0 indicates succes,
  less than zero for failure:
.PP
.Vb 5
\&    OV_EREAD - A read from media returned an error.
\&    OV_ENOTVORBIS - Bitstream is not Vorbis data.
\&    OV_EVERSION - Vorbis version mismatch.
\&    OV_EBADHEADER - Invalid Vorbis bitstream header.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
.Ve
.Sh "ov_clear"
.IX Subsection "ov_clear"
\&\fIov_clear()\fR to clear the decoder's buffers and close the file
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_clear.html>
.PP
\&\-Input:
  OggVorbis_File
.PP
\&\-Output:
  0 for success
.Sh "ov_seekable"
.IX Subsection "ov_seekable"
This indicates whether or not the bitstream is seekable. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_seekable.html>
.PP
\&\-Input:
  OggVorbis_File
.PP
\&\-Output:
  0 indicates that the file is not seekable.
  nonzero indicates that the file is seekable.
.Sh "ov_time_total"
.IX Subsection "ov_time_total"
Returns the total time in seconds of the physical bitstream or a specified logical bitstream. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_time_total.html>
.PP
\&\-Input:
  OggVorbis_File,
  int (link to the desired logical bitstream)
.PP
\&\-Output:
  \s-1OV_EINVAL\s0 means that the argument was invalid. In this case, the requested bitstream did not exist or the bitstream is nonseekable.
  n total length in seconds of content if i=\-1.
  n length in seconds of logical bitstream if i=0 to n.
.Sh "ov_time_seek"
.IX Subsection "ov_time_seek"
For seekable streams, this seeks to the given time.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_time_seek.html>
.PP
\&\-Input:
  OggVorbis_File,
  double (location to seek in seconds)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 5
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_raw_seek"
.IX Subsection "ov_raw_seek"
For seekable streams, this seeks to the given offset in compressed raw bytes.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_raw_seek.html>
.PP
\&\-Input:
  OggVorbis_File,
  long (location to seek in compressed raw bytes)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 5
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_pcm_seek"
.IX Subsection "ov_pcm_seek"
Seeks to the offset specified (in pcm samples) within the physical bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_pcm_seek.html>
.PP
\&\-Input:
  OggVorbis_File,
  ogg_int64_t, (location to seek in pcm samples)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 5
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_pcm_seek_page"
.IX Subsection "ov_pcm_seek_page"
Seeks to the closest page preceding the specified location (in pcm samples).
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_pcm_seek_page.html>
.PP
\&\-Input:
  OggVorbis_File,
  ogg_int64_t (position in pcm samples to seek to in the bitstream)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 5
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_time_seek_page"
.IX Subsection "ov_time_seek_page"
For seekable streams, this seeks to closest full page preceding the given time.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_time_seek_page.html>
.PP
\&\-Input:
  OggVorbis_File,
  double (Location to seek to within the file, specified in seconds)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 5
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_raw_seek_lap"
.IX Subsection "ov_raw_seek_lap"
Seeks to the offset specified (in compressed raw bytes) within the physical bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_raw_seek_lap.html>
.PP
\&\-Input:
  OggVorbis_File,
  ogg_int64_t (Location to seek to within the file, specified in compressed raw bytes)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 6
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EOF - Indicates stream is at end of file immediately after a seek
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_pcm_seek_lap"
.IX Subsection "ov_pcm_seek_lap"
Seeks to the offset specified (in pcm samples) within the physical bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_pcm_seek_lap.html>
.PP
\&\-Input:
  OggVorbis_File,
  long (Location to seek to within the file, specified in pcm samples)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 6
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EOF - Indicates stream is at end of file immediately after a seek
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_time_seek_lap"
.IX Subsection "ov_time_seek_lap"
Seeks to the offset specified (in seconds) within the physical bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_time_seek_lap.html>
.PP
\&\-Input:
  OggVorbis_File,
  double (Location to seek to within the file, specified in seconds)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 6
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EOF - Indicates stream is at end of file immediately after a seek
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_time_page_seek_lap"
.IX Subsection "ov_time_page_seek_lap"
For seekable streams, ov_time_seek_page_lap seeks to the closest full page preceeding the given time.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_time_seek_page_lap.html>
.PP
\&\-Input:
  OggVorbis_File,
  double (Location to seek to within the file, specified in seconds)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 6
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EOF - Indicates stream is at end of file immediately after a seek
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_pcm_page_seek_lap"
.IX Subsection "ov_pcm_page_seek_lap"
Seeks to the closest page preceding the specified location (in pcm samples) within the physical bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_pcm_seek_page_lap.html>
.PP
\&\-Input:
  OggVorbis_File,
  ogg_int64_t (Location to seek to within the file, specified in pcm samples)
.PP
\&\-Output:
  0 for success
  nonzero indicates failure, described by several error codes:
.PP
.Vb 6
\&    OV_ENOSEEK - Bitstream is not seekable.
\&    OV_EINVAL - Invalid argument value; possibly called with an OggVorbis_File structure that isn't open.
\&    OV_EREAD - A read from media returned an error.
\&    OV_EOF - Indicates stream is at end of file immediately after a seek
\&    OV_EFAULT - Internal logic fault; indicates a bug or heap/stack corruption.
\&    OV_EBADLINK - Invalid stream section supplied to libvorbisfile, or the requested link is corrupt.
.Ve
.Sh "ov_streams"
.IX Subsection "ov_streams"
Returns the number of logical bitstreams within our physical bitstream. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_streams.html>
.PP
\&\-Input:
  OggVorbis_File
.PP
\&\-Output:
  1 indicates a single logical bitstream or an unseekable file,
  n indicates the number of logical bitstreams.
.Sh "ov_info"
.IX Subsection "ov_info"
Returns the vorbis_info struct for the specified bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_info.html>
.PP
\&\-Input:
  OggVorbis_File,
  int (link to desired logical bitstream)
.PP
\&\-Output:
  Returns the vorbis_info struct for the specified bitstream,
  \s-1NULL\s0 if the specified bitstream does not exist or the file has been initialized improperly.
.Sh "ov_bitrate"
.IX Subsection "ov_bitrate"
Function returns the average bitrate for the specified logical bitstream. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_bitrate.html>
.PP
\&\-Input:
  OggVorbis_File,
  int (desired logical bitstream)
.PP
\&\-Output:
    \s-1OV_EINVAL\s0 indicates that an invalid argument value or that the stream represented by vf is not open,
    \s-1OV_FALSE\s0 means the call returned a 'false' status, 
    n indicates the bitrate for the given logical bitstream or the entire physical bitstream.
.Sh "ov_bitrate_instant"
.IX Subsection "ov_bitrate_instant"
Function returns the average bitrate for the specified logical bitstream. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_bitrate_instant.html>
.PP
\&\-Input:
  OggVorbis_File.
.PP
\&\-Output:
    0 indicates the beginning of the file or unchanged bitrate info.
    \s-1OV_EINVAL\s0 indicates that an invalid argument value or that the stream represented by vf is not open,
    \s-1OV_FALSE\s0 means the call returned a 'false' status, 
    n indicates the actual bitrate since the last call.
.Sh "ov_serialnumber"
.IX Subsection "ov_serialnumber"
serialnumber of the specified logical bitstream link number within the overall physical bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_serialnumber.html>
.PP
\&\-Input:
  OggVorbis_File,
  int (desired logical bitstream)
.PP
\&\-Output:
  \-1 if the specified logical bitstream i does not exist,
  serial number of the logical bitstream i or the serial number of the current bitstream.
.Sh "ov_raw_total"
.IX Subsection "ov_raw_total"
total (compressed) bytes of the physical bitstream or a specified logical bitstream. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_raw_total.html>
.PP
\&\-Input:
  OggVorbis_File,
  int (desired logical bitstream)
.PP
\&\-Output:
  \s-1OV_EINVAL\s0 means that the argument was invalid
  n total length in compressed bytes of content if i=\-1
  n length in compressed bytes of logical bitstream if i=0 to n
.Sh "ov_pcm_total"
.IX Subsection "ov_pcm_total"
Returns the total pcm samples of the physical bitstream or a specified logical bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_pcm_total.html>
.PP
\&\-Input:
  OggVorbis_File,
  int (desired logical bitstream)
.PP
\&\-Output:
  \s-1OV_EINVAL\s0 means that the argument was invalid
  n total length in pcm samples of content if i=\-1
  n length in pcm samples of logical bitstream if i=0 to n
.Sh "ov_raw_tell"
.IX Subsection "ov_raw_tell"
Returns the current offset in raw compressed bytes.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_raw_tell.html>
.PP
\&\-Input:
  OggVorbis_File
.PP
\&\-Output:
  n indicates the current offset in bytes,
  \s-1OV_EINVAL\s0 means that the argument was invalid.
.Sh "ov_pcm_tell"
.IX Subsection "ov_pcm_tell"
Returns the current offset in samples. 
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_pcm_tell.html>
.PP
\&\-Input:
  OggVorbis_File
.PP
\&\-Output:
  n indicates the current offset in samples,
  \s-1OV_EINVAL\s0 means that the argument was invalid.
.Sh "ov_time_tell"
.IX Subsection "ov_time_tell"
Returns the current decoding offset in seconds.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_time_tell.html>
.PP
\&\-Input:
  OggVorbis_File
.PP
\&\-Output:
  n indicates the current decoding time offset in seconds,
  \s-1OV_EINVAL\s0 means that the argument was invalid.
.Sh "ov_comment"
.IX Subsection "ov_comment"
Returns a pointer to the vorbis_comment struct for the specified bitstream.
<http://www.xiph.org/vorbis/doc/vorbisfile/ov_comment.html>
.PP
\&\-Input:
  OggVorbis_File,
  int (link to desired logical bitstream)
.PP
\&\-Output:
  Returns the vorbis_comment struct for the specified bitstream,
  \s-1NULL\s0 if the specified bitstream does not exist or the file has been initialized improperly.
.SH "Decoding (vorbisfile)"
.IX Header "Decoding (vorbisfile)"
.Sh "ov_read"
.IX Subsection "ov_read"
Decode a Vorbis file within a loop. <http://www.xiph.org/vorbis/doc/vorbisfile/ov_read.html>
.PP
\&\-Input:
  OggVorbis_File *vf, 
  char *buffer, 
  int length, 
  int bigendianp, (big or little endian byte packing. 0 for little endian, 1 for b ig endian)
  int word, (word size)
  int sgned, (1 for signed or 0 for unsigned)
  int *bitstream
.PP
\&\-Output:
  \s-1OV_HOLE\s0, interruption in the data
  \s-1OV_EBADLINK\s0, invalid stream section
  \s-1OV_EINVAL\s0, initial file headers couldn't be read or are corrupt
  0, \s-1EOF\s0
  n, actual number of bytes read
.Sh "ov_read_float"
.IX Subsection "ov_read_float"
\&\fB\s-1TODO\s0\fR Returns samples in native float format instead of in integer formats.
.Sh "ov_read_filter"
.IX Subsection "ov_read_filter"
\&\fB\s-1TODO\s0\fR It passes the decoded floating point \s-1PCM\s0 data to the filter specified in the function arguments before 
converting the data to integer output samples. (variant of \fIov_read()\fR)
.SH "Encoding"
.IX Header "Encoding"
.Sh "vorbis_info_init"
.IX Subsection "vorbis_info_init"
This function initializes a vorbis_info structure and allocates its internal storage.
<http://www.xiph.org/vorbis/doc/libvorbis/vorbis_info_init.html>
.PP
\&\-Input:
  vi, Pointer to a vorbis_info struct to be initialized.
.PP
\&\-Output:
  void
.Sh "vorbis_encode_init_vbr"
.IX Subsection "vorbis_encode_init_vbr"
This is the primary function within libvorbisenc for setting up variable 
bitrate (\*(L"quality\*(R" based) modes. 
.PP
\&\-Input:
  vorbis_info *vi,
  long channels (number of channels to be encoded),
  long rate (sampling rate of the source audio),
  float base_quality (desired quality level, currently from \-0.1 to 1.0 [lo to hi])
.PP
\&\-Output:
  0 for success
  less than zero for failure:
    \s-1OV_EFAULT\s0 \- Internal logic fault; indicates a bug or heap/stack corruption.
    \s-1OV_EINVAL\s0 \- Invalid setup request, eg, out of range argument.
    \s-1OV_EIMPL\s0 \- Unimplemented mode; unable to comply with quality level request.
.Sh "vorbis_analysis_init"
.IX Subsection "vorbis_analysis_init"
This function allocates and initializes the encoder's analysis state inside a is 
vorbis_dsp_state, based on the configuration in a vorbis_info struct. 
<http://www.xiph.org/vorbis/doc/libvorbis/vorbis_analysis_init.html>
.PP
\&\-Input:
  vorbis_dsp_state *v,
  vorbis_info *vi
.PP
\&\-Output:
  0 for \s-1SUCCESS\s0
.Sh "vorbis_block_init"
.IX Subsection "vorbis_block_init"
This function initializes a vorbis_block structure and allocates its internal storage.
<http://www.xiph.org/vorbis/doc/libvorbis/vorbis_block_init.html>
.PP
\&\-Input:
  vorbis_dsp_state *v,
  vorbis_block *vb
.PP
\&\-Output:
  0 (for success)
.Sh "vorbis_encode_setup_init"
.IX Subsection "vorbis_encode_setup_init"
This function performs the last stage of three-step encoding setup, as 
described in the \s-1API\s0 overview under managed bitrate modes. 
<http://xiph.org/vorbis/doc/vorbisenc/vorbis_encode_setup_init.html>
.PP
\&\-Input:
  vorbis_info *vi
.PP
\&\-Output:
  0 for success
  less than zero for failure:
    \s-1OV_EFAULT\s0 \- Internal logic fault; indicates a bug or heap/stack corruption.
    \s-1OV_EINVAL\s0 \- Attempt to use \fIvorbis_encode_setup_init()\fR without first calling one of \fIvorbis_encode_setup_managed()\fR 
                or \fIvorbis_encode_setup_vbr()\fR to initialize the high-level encoding setup
.Sh "vorbis_comment_init"
.IX Subsection "vorbis_comment_init"
This function initializes a vorbis_comment structure for use.
<http://www.xiph.org/vorbis/doc/libvorbis/vorbis_comment_init.html>
.PP
\&\-Input:
  vorbis_comment *vc
.PP
\&\-Ouput:
  void
.Sh "vorbis_analysis_headerout(v, vc, op, op_comm, op_code)"
.IX Subsection "vorbis_analysis_headerout(v, vc, op, op_comm, op_code)"
This function creates and returns the three header packets needed to configure a decoder to 
accept compressed data. <http://www.xiph.org/vorbis/doc/libvorbis/vorbis_analysis_headerout.html>
.PP
\&\-Input:
  vorbis_dsp_state *v,
  vorbis_comment *vc,
  ogg_packet *op,
  ogg_packet *op_comm,
  ogg_packet *op_code
.PP
\&\-Output:
  0 for success
  negative values for failure:
    \s-1OV_EFAULT\s0 \- Internal fault; indicates a bug or memory corruption.
    \s-1OV_EIMPL\s0 \- Unimplemented; not supported by this version of the library.
.Sh "vorbis_analysis_wrote"
.IX Subsection "vorbis_analysis_wrote"
This function tells the encoder new data is available for compression. 
<http://www.xiph.org/vorbis/doc/libvorbis/vorbis_analysis_wrote.html>
.PP
\&\-Input:
  vorbis_dsp_state *v,
  int vals
.PP
\&\-Output:  
  0 for success
  negative values for failure:
    \s-1OV_EINVAL\s0 \- Invalid request; e.g. vals overflows the allocated space,
    \s-1OV_EFAULT\s0 \- Internal fault; indicates a bug or memory corruption,
    \s-1OV_EIMPL\s0 \- Unimplemented; not supported by this version of the library.
.Sh "vorbis_analysis_blockout"
.IX Subsection "vorbis_analysis_blockout"
This fuction examines the available uncompressed data and tries to break it into appropriate 
sized blocks. <http://www.xiph.org/vorbis/doc/libvorbis/vorbis_analysis_blockout.html>
.PP
\&\-Input:
  vorbis_dsp_state *,
  vorbis_block *
.PP
\&\-Output:
  1 for success when more blocks are available.
  0 for success when this is the last block available from the current input.
  negative values for failure:
    \s-1OV_EINVAL\s0 \- Invalid parameters.
    \s-1OV_EFAULT\s0 \- Internal fault; indicates a bug or memory corruption.
    \s-1OV_EIMPL\s0 \- Unimplemented; not supported by this version of the library.
.Sh "vorbis_analysis"
.IX Subsection "vorbis_analysis"
Once the uncompressed audio data has been divided into blocks, this function is called on each block. 
It looks up the encoding mode and dispatches the block to the forward transform provided by that mode. 
<http://www.xiph.org/vorbis/doc/libvorbis/vorbis_analysis.html>
.PP
\&\-Input:
  vorbis_block *,
  ogg_packet *
.PP
\&\-Output:
   0 for success
   negative values for failure:
     \s-1OV_EINVAL\s0 \- Invalid request; a non-NULL value was passed for op when the encoder is using a bitrate managed mode.
     \s-1OV_EFAULT\s0 \- Internal fault; indicates a bug or memory corruption.
     \s-1OV_EIMPL\s0 \- Unimplemented; not supported by this version of the library.
.SH "Miscellaneous Functions"
.IX Header "Miscellaneous Functions"
These functions are not found in libvorbis*, but is written by the \s-1XS\s0 author
to simplify few tasks.
.Sh "get_vorbis_info"
.IX Subsection "get_vorbis_info"
Returns a HashRef with vorbis_info struct values.
<http://www.xiph.org/vorbis/doc/libvorbis/vorbis_info.html>
.PP
\&\-Input:
  vorbis_info
.PP
\&\-Output:
  HashRef
.Sh "get_vorbis_comment"
.IX Subsection "get_vorbis_comment"
Returns a HashRef with vorbis_comment struct values.
<http://www.xiph.org/vorbis/doc/libvorbis/vorbis_comment.html>
.PP
\&\-Input:
  vorbis_comment *
.PP
\&\-Output:
  HashRef
.Sh "vorbis_encode_wav_frames"
.IX Subsection "vorbis_encode_wav_frames"
This function encode the given frames. It calls vorbis_analysis_buffer and
vorbis_analysis_wrote internally to give the data to the encode for compression.
.PP
\&\-Input:
  vorbis_dsp_state *,
  int (number of samples to provide space for in the returned buffer),
  channels,
  data buffer
.PP
\&\-Output:
  same as of vorbis_analysis_wrote
.SH "CAVEATS"
.IX Header "CAVEATS"
This Modules expects the Theora file to be contained in an Ogg container (which true for most of the vorbis audio
at the time of writing this module). Few of the miscellaneous functions like \fBvorbis_encode_wav_frames\fR are not optimized. 
This module seems to give \fBSegmentation Fault\fR if the version of libvorbis are old. In my system (Mac \s-1OS\s0 X, 10.5.8) 
when i wrote this module, I was using libvorbis \f(CW@1\fR.2.3_0 (active) and libogg \f(CW@1\fR.1.4_0 (active).
.SH "TODO"
.IX Header "TODO"
Decode is supported only via vorbisfile \*(L"vorbis/doc/vorbisfile/overview.html\*(R" in www.xiph.org, 
need to add decoding using raw decode functions as mentioned in <http://www.xiph.org/vorbis/doc/libvorbis/overview.html>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Ogg::LibOgg, Ogg::LibOgg
.PP
Vorbis Documentation, <http://www.xiph.org/vorbis/doc/>
.SH "AUTHOR"
.IX Header "AUTHOR"
Vigith Maurice, <vigith@cpan.org<gt>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2012 by Vigith Maurice, www.vigith.com <vigith@yahoo\-inc.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.9 or,
at your option, any later version of Perl 5 you may have available.
